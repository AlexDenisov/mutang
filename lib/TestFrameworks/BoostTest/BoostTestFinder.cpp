#include "mull/TestFrameworks/BoostTest/BoostTestFinder.h"
#include "mull/Program/Program.h"

#include "LLVMCompatibility.h"

#include <list>
#include <map>
#include <string>
#include <sstream>

using namespace mull;
using namespace llvm;

namespace {
  template<typename Container>
  std::string computeTestPath(const std::string &symbolName, const Container &testSuitePaths){
    // Hack: Cut away any template arguments as a workaround for templated test
    // cases not being properly detected
    auto templatePos = symbolName.find('<');
    auto pos = symbolName.rfind("::", templatePos);
    if (pos != std::string::npos) {
      pos += 2; // skip past the "::"
    }
    else {
      pos = 0;
    }
    std::string baseName = symbolName.substr(pos);
    if (templatePos != std::string::npos) {
      // Use wildcard match for templated cases
      // This will cause additional overhead because unmutated test cases will be run in addition
      // to the one being mutated, so this is only a workaround to get _any_ results.
      baseName = symbolName.substr(pos, templatePos - pos) + "<*";
    }
    auto symbolPath = symbolName.substr(0, pos);
    for (auto it = std::rbegin(testSuitePaths); it != std::rend(testSuitePaths); ++it) {
      // Check if the symbol begins with the test suite namespace
      if (symbolPath.rfind(it->first, 0) != std::string::npos) {
        return it->second + "/" + baseName;
      }
    }
    return baseName;
  }
}

std::vector<Test> BoostTestFinder::findTests(Program &program) {
  // All Boost.Test test cases and suites have a registrar object that
  // takes care of self-registering the test via global constructors.
  // Test suites are used for grouping multiple test cases or suites
  // together. All test suites are also registered through the registrar
  // objects. The test suite macro also automatically adds a namespace
  // named the same as the test suite so that the test cases are naturally
  // grouped when looking at a symbol list.
  // Test suites additionally have a test_suite::end_suite_registrar object
  // which is generated by the BOOST_AUTO_TEST_SUITE_END macro

  // Our algorithm for finding test cases and suites is as follows:
  // 1. Find all objects named end_suite_registrar to find all test suites
  // 2. Use the test suite symbol names to discover the structure of the test tree
  // 3. Find all methods named test_method(), these are test cases.
  // 4. Assign each test case a full path name, e.g. "myGroup/mySuite/myTestCase1"

  // Note that while this works for automatically registered test cases,
  // e.g. when using BOOST_FIXTURE_TEST_CASE or BOOST_AUTO_TEST_CASE,
  // it is possible that this algorithm may fail to properly detect
  // manually registered test suites and test cases, especially if the
  // test is not using the standard test implementation templates
  // (BOOST_FIXTURE_TEST_CASE_TEMPLATE or BOOST_FIXTURE_TEST_CASE_WITH_DECOR).

  std::map<std::string, Test> testCases;
  for (auto &bitcode : program.bitcode()) {
    // Find all test suites first
    std::list<std::string> testSuiteNamespaces;
    for (auto &globalVar : bitcode->getModule()->getGlobalList()) {
      if (globalVar.isDeclaration()) {
        continue;
      }
      auto name = globalVar.getName();
      if (name.find("end_suite_registrar") == llvm::StringRef::npos) {
        continue;
      }
      std::string demangledName = llvm_compat::demangle(name);
      auto posEnd = demangledName.rfind("::end_suite_registrar");
      if (posEnd == std::string::npos || demangledName.find("::", posEnd + 1) != std::string::npos) {
        // false match
        continue;
      }
      // End suite marker found
      std::string suiteNamespace = demangledName.substr(0, posEnd);
      // Insert suite ordered by path length, this will simplify building the tree further down
      auto it = std::begin(testSuiteNamespaces);
      while (it != std::end(testSuiteNamespaces) && it->size() < suiteNamespace.size()) {
        ++it;
      }
      testSuiteNamespaces.insert(it, suiteNamespace);
    }
    std::vector<std::pair<std::string, std::string> > testSuitePaths;
    for (const auto &suiteNamespace : testSuiteNamespaces) {
      auto fullPath = computeTestPath(suiteNamespace, testSuitePaths);
      testSuitePaths.emplace_back(suiteNamespace + "::", fullPath);
    }
    // Find all test cases within this module
    for (auto &func : bitcode->getModule()->getFunctionList()) {
      if (func.isDeclaration()) {
        continue;
      }
      auto name = func.getName();
      // The actual test case implementation is always `void test_method()` in the test case subclass
      if (name.find("test_method") == llvm::StringRef::npos) {
        continue;
      }
      std::string demangledName = llvm_compat::demangle(name);
      // Check that the demangled name ends with ::test_method() to
      // filter out lambdas and other methods which are not really test cases
      constexpr std::string::size_type testMethodStrLength = 15; // std::string("::test_method()").length()
      auto posEnd = demangledName.find("::test_method()", demangledName.size() - testMethodStrLength);
      if (posEnd == std::string::npos) {
        // false match
        continue;
      }
      auto fullPath = computeTestPath(demangledName.substr(0, posEnd), testSuitePaths);
      std::ostringstream ss;
      ss << "Found test case: " << fullPath;
      diagnostics.debug(ss.str());
      auto arguments = { std::string("--run_test=") + fullPath };

      // Try to insert a new test case
      auto kv_added =
          testCases.emplace(std::piecewise_construct,
                            std::forward_as_tuple(fullPath),
                            std::forward_as_tuple(fullPath, "mull", "main", arguments, &func));
      if (!kv_added.second) {
        // Already exists in map, append our test method
        diagnostics.debug(fullPath + " exists, adding another test entry point");
        Test &test = kv_added.first->second;
        test.addTestFunction(&func);
      }
    }
  }

  std::vector<Test> tests;
  tests.reserve(testCases.size());
  for (auto &kv : testCases) {
    tests.push_back(std::move(kv.second));
  }

  return tests;
}
